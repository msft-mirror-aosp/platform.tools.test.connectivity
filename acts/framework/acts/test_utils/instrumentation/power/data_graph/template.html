<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="https://www.gstatic.com/external_hosted/dygraphs/dygraph-combined.js"></script>
<!-- script placeholder -->
<script>
const INDICATOR_VALUE = 3000;

// Since we roughly have 1 sample every 2 milliseconds
const SAMPLE_PER_MILLISEC = 0.5;

charting = {};

charting.colors = [ "#4285F4", "#34A853", "#EA4335", "#FBBC05" ];

charting.zoomHistory = [];

charting.globalMetrics = [$GLOBALMETRICS];

charting.data = [$POWERDATA];

charting.padLeft = function(str, length, character){
  if (character.length != 1){
   throw "Invalid padding character";
  }

  let padding = Array(length + 1).join(character);
  // making sure the input is treated as String
  str = str + "";
  return padding.substring(0, length - str.length) + str;
}

// generates a converter function.
charting.msToDateConverter = function(includeMicro) {
   return function(ms){
      let date = new Date(Math.trunc(ms));
      let microSec = Math.trunc((ms - Math.trunc(ms)) * 1000);

      let s = charting.padLeft(date.getUTCSeconds(), 2, "0");
      let m = charting.padLeft(date.getUTCMinutes(), 2, "0");
      let h = charting.padLeft(date.getUTCHours(),   2, "0");
      let result = h + ":" + m + ":" + s
      if(includeMicro){
         let mms = charting.padLeft(date.getMilliseconds() * 1000 + microSec, 6, "0");
         result += `.${mms}`;
      }
      return result;
   }
}

/* gets the index of the best of approximation for a given x-value */
charting.getIndex = function(g, value){
   let min = 0;
   let max = g.numRows() - 1;
   let middle = parseInt((max + min) / 2);

   let i = 0;
   while (max > min){
      if (g.getValue(middle, 0) > value) {
         max = middle - 1;
      } else {
         min = middle + 1;
      }
      middle = parseInt((max + min) / 2);
   }
   return middle;
}

charting.getChartMetrics = function(g) {
   let timeColumn = 0;
   let lower = charting.getIndex(g, g.xAxisRange()[0]);
   let upper = charting.getIndex(g, g.xAxisRange()[1]);
   let metrics = [];

   for (let valueColumn = 1; valueColumn < g.numColumns(); valueColumn++) {
      let sum = 0;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (let i = lower; i <= upper; i++){
         let value = g.getValue(i, valueColumn);
         if (value < INDICATOR_VALUE) {
            sum += value;
            minValue = minValue < value ? minValue : value;
            maxValue = value < maxValue ? maxValue : value;
         }
      }
      let average  = sum / (upper - lower + 1);
      let duration = g.getValue(upper, timeColumn) - g.getValue(lower, timeColumn) + 1;
      metrics.push({
         average  : Math.round(average  * 1000) / 1000,
         maxValue : Math.round(maxValue * 1000) / 1000,
         minValue : Math.round(minValue * 1000) / 1000,
         duration : duration,
      });
   }

   return metrics;
}

charting.toChartInfoHtml = function(metrics, color) {
   return `
   <div class="chart-info">
      <div style="color:${color}">Average:   <span>${metrics.average}</span></div>
      <div style="color:${color}">Max:       <span>${metrics.maxValue}</span></div>
      <div style="color:${color}">Min:       <span>${metrics.minValue}</span></div>
      <div style="color:${color}">Duration:  <span>${(metrics.duration / 1000).toFixed(3)} s</span></div>
   </div>
   `;
}

charting.metricsUpdateTimeoutId = 0;
charting.updateMetrics = function(g, isInitial) {
   clearTimeout(charting.metricsUpdateTimeoutId);
   charting.metricsUpdateTimeoutId = setTimeout(function(){
      let metrics = isInitial ? [ charting.globalMetrics ] : charting.getChartMetrics(g)
      let statisticsContainer = document.getElementById("statistics");
      let innerHTML = "";
      for(let valueColumn = 0; valueColumn < metrics.length; valueColumn++) {
         if (g.visibility()[valueColumn]) {
            let metricInfo = charting.toChartInfoHtml(metrics[valueColumn], g.colors_[valueColumn]);
            innerHTML += metricInfo;
         }
      }
      statisticsContainer.innerHTML = innerHTML;
   }, 50);
}

charting.drawCallback = function(g, isInitial) {
   charting.updateMetrics(g, isInitial);
}

charting.zoomCallback = function(xMin, xMax, yRanges) {
   let [xGlobalMin, xGlobalMax] = charting.graph.xAxisExtremes();
   if (xMin === xGlobalMin && xMax === xGlobalMax) {
      charting.zoomHistory = [];
   } else if (charting.zoomHistory.length === 0) {
      charting.zoomHistory.push([xMin, xMax]);
   } else {
      let [topXmin, topXmax] = charting.zoomHistory[charting.zoomHistory.length - 1];
      let topStackDistance = topXmax - topXmin;
      let distance = xMax - xMin;

      if (distance < topStackDistance) {
         charting.zoomHistory.push([xMin, xMax]);
      }
   }
}

charting.restorePosition = function() {
   charting.graph.resetZoom();
   charting.zoomHistory = [];
}

charting.toogleFixedRange = function(e) {
   if (e.target.checked) {
      charting.fixRange();
      return;
   }
   charting.graph.updateOptions({ valueRange: [null, null] });
}

charting.toogleFilterOptions1 = function(e) {
   if (e.target.checked) {
      charting.elements.peakFilterOptions1.style.display = "block";
      charting.graph.setVisibility(1, true);
   } else {
      charting.elements.peakFilterOptions1.style.display = "none";
      charting.graph.setVisibility(1, false);
   }
}

charting.toogleFilterOptions2 = function(e) {
   if (e.target.checked) {
      charting.elements.peakFilterOptions2.style.display = "block";
      charting.graph.setVisibility(2, true);
   } else {
      charting.elements.peakFilterOptions2.style.display = "none";
      charting.graph.setVisibility(2, false);
   }
}

charting.toogleData = function(e) {
   charting.graph.setVisibility(0, e.target.checked);
}

charting.fixRange = function() {
   if (typeof charting.initialMetrics == "undefined" ){
     charting.initialMetrics = charting.getChartMetrics(charting.graph);
   }

   let metrics = charting.initialMetrics;
   let visibleRange = metrics.maxValue - metrics.minValue;
   let buffer = visibleRange / 10; // 10%
   let min = metrics.minValue - buffer;
   let max = metrics.maxValue + buffer;
   charting.graph.updateOptions({ valueRange: [min, max] });
}

charting.addXLabelPlaceholder = function() {
   charting.elements.labelsDiv.className = "empty";
}

charting.removeXLabelPlaceholder = function() {
   charting.elements.labelsDiv.className = "";
}

charting.filterPeaks = function(element, dataIndex) {
   console.log("start");
   let lowerThreshold = element.parentElement.querySelector("#lower-threshold").value;
   let upperThreshold = element.parentElement.querySelector("#upper-threshold").value;
   let frequency = element.parentElement.querySelector("#frequency").value;

   let peaks = charting.findPeaks(lowerThreshold, upperThreshold, frequency);

   let currentData = charting.data.map(entry => entry[1]);
   for (let peak of peaks) {
      for (let point = peak.start; point <= peak.end; point++) {
         currentData[point] = charting.globalMetrics.average;
      }
   }

   for (let i = 0; i < charting.data.length; i++) {
      charting.data[i][dataIndex] = currentData[i];
   }

   charting.graph.updateOptions({
      file: charting.data,
   });

   console.log("done");
}

charting.findPeaks = function(lowerThreshold, upperThreshold, frequency) {
   const SAMPLE_SIZE = 4;
   const CONSECUTIVE_PEAKS = 3;

   let index = 0;
   let peaks = [];
   let runningSum = null;
   let consecutivePeaks = 0;
   while (index < charting.data.length) {
      if (peaks.length === 0) {
         runningSum = charting.findWindowSumShiftLeft(index - SAMPLE_SIZE/2, index + SAMPLE_SIZE/2, runningSum);
         let average = runningSum/(SAMPLE_SIZE + 1);
         if (average >= charting.globalMetrics.average) {
            let peak = charting.findPeakInfo(index);
            if (lowerThreshold <= charting.data[peak.highestPoint][1] && charting.data[peak.highestPoint][1] <= upperThreshold) {
               peaks.push(peak);
               index = peak.highestPoint + Math.floor(frequency * SAMPLE_PER_MILLISEC);
               consecutivePeaks++;
            } else {
               index = peak.end + SAMPLE_SIZE / 2;
            }
         } else {
            index++;
         }
      } else {
         // We will look around +- 10% from the frequency
         let surveyWindow = Math.floor(frequency / 10);
         let lowerBound = index - Math.floor(surveyWindow * SAMPLE_PER_MILLISEC);
         let upperBound = index + Math.floor(surveyWindow * SAMPLE_PER_MILLISEC);
         let found = false;
         runningSum = null;
         for (let i = lowerBound; !found && i <= upperBound && i < charting.data.length; i++) {
            runningSum = charting.findWindowSumShiftLeft(i - SAMPLE_SIZE/2, i + SAMPLE_SIZE/2, runningSum);
            let average = runningSum / (SAMPLE_SIZE + 1);
            if (average > charting.globalMetrics.average) {
               let peak = charting.findPeakInfo(i);
               if (lowerThreshold <= charting.data[peak.highestPoint][1] && charting.data[peak.highestPoint][1] <= upperThreshold) {
                  peaks.push(peak);
                  found = true;
                  index = peak.highestPoint + Math.floor(frequency * SAMPLE_PER_MILLISEC);
                  consecutivePeaks++;
               } else {
                  i = peak.end + SAMPLE_SIZE / 2;
               }
            }
         }

         if (!found) {
            if (consecutivePeaks < CONSECUTIVE_PEAKS) {
               index = peaks[0].end + SAMPLE_SIZE / 2;
               runningSum = null;
               consecutivePeaks = 0;
               peaks = [];
            } else {
               index = index + Math.floor(frequency * SAMPLE_PER_MILLISEC);
            }
         }
      }
   }

   return peaks;
}

charting.findPeakInfo = function(peak) {
   // We make it so that the WINDOW_SIZE to calculate peak start and end to be equal to the
   // sample size used to calculate sum. This will narrow the peak down.
   const WINDOW_SIZE = 3;
   let start = charting.findPeakStart(peak, WINDOW_SIZE);
   let end = charting.findPeakEnd(peak, WINDOW_SIZE);

   let highestPoint = start;
   for (let i = start; i < charting.data.length && i <= end; i++) {
      if (charting.data[i][1] < INDICATOR_VALUE && charting.data[highestPoint][1] < charting.data[i][1]) {
         highestPoint = i;
      }
   }

   return {start, end, highestPoint};
}

charting.findPeakStart = function(peak, windowSize) {
   let start = peak - windowSize + 1;
   let end = peak;
   let runningSum = null;
   let average = 0;

   do {
      runningSum = charting.findWindowSumShiftRight(start, end, runningSum);
      average = runningSum / windowSize;
      start--;
      end--;
   } while (average > charting.globalMetrics.average && start >= 0)
   return start >= 0 ? start + 1 : 0;
}

charting.findPeakEnd = function(peak, windowSize) {
   let start = peak;
   let end = peak + windowSize - 1;
   let runningSum = null;
   let average = 0;

   do {
      runningSum = charting.findWindowSumShiftLeft(start, end, runningSum);
      average = runningSum / windowSize;
      start++;
      end++;
   } while (average > charting.globalMetrics.average && end < charting.data.length)
   return end < charting.data.length ? end - 1: charting.data.length;
}

charting.findWindowSumShiftLeft = function(start, end, runningSum) {
  try {
   if (start < 0) {
      start = 0;
   }

   if (end >= charting.data.length) {
      end = charting.data.length;
   }

   if (runningSum === null) {
         runningSum = 0;
         for (let i = start; i < charting.data.length && i <= end; i++) {
            if (charting.data[i][1] < INDICATOR_VALUE)
               runningSum += charting.data[i][1];
         }
      } else {
         if (start > 0 && charting.data[start-1][1] < INDICATOR_VALUE)
            runningSum -= charting.data[start-1][1];

         if (end < charting.data.length && charting.data[end][1] < INDICATOR_VALUE)
            runningSum += charting.data[end][1];
      }

      return runningSum;
  } catch (error) {
     console.log(error);
     console.log(start, end, charting.data.length);
  }
}

charting.findWindowSumShiftRight = function(start, end, runningSum) {
   if (start < 0) {
    start = 0;
   }

  if (end >= charting.data.length) {
    end = charting.data.length;
  }

  if (runningSum === null) {
      runningSum = 0;
      for (let i = start; i < charting.data.length && i <= end; i++) {
         if (charting.data[i][1] < INDICATOR_VALUE)
            runningSum += charting.data[i][1];
      }
   } else {
      if (start >= 0 && charting.data[start][1] < INDICATOR_VALUE)
         runningSum += charting.data[start][1];

      if (end < charting.data.length - 1 && charting.data[end+1][1] < INDICATOR_VALUE)
         runningSum -= charting.data[end+1][1];
   }

   return runningSum;
}

charting.interactionModel = Dygraph.defaultInteractionModel;
charting.interactionModel.dblclick = function(event, graph, context) {
   if (context.cancelNextDbclick) {
      context.cancelNextDbclick = false;
      return;
   }

   if (event.altKey || event.shiftKey) {
      return;
   }

   // pop current view out
   if (charting.zoomHistory.length !== 0) {
      charting.zoomHistory.pop();
      if (charting.zoomHistory.length === 0) {
         graph.resetZoom();
      } else {
         graph.updateOptions({
            dateWindow: charting.zoomHistory[charting.zoomHistory.length - 1]
         });
      }
   }
}

charting.buildChart = function() {
   charting.elements = {
      graphDiv      : document.getElementById("graph-div"),
      labelsDiv     : document.getElementById("labels-div"),
      rangeCheckbox : document.getElementById("range-checkbox"),
      dataFilterCheckbox: document.getElementById("data-filter-checkbox"),
      peakFilterCheckbox1: document.getElementById("peak-filter-checkbox-1"),
      peakFilterOptions1: document.getElementById("peak-filter-options-1"),
      peakFilterCheckbox2: document.getElementById("peak-filter-checkbox-2"),
      peakFilterOptions2: document.getElementById("peak-filter-options-2"),
  }

  let graph = new Dygraph(
      charting.elements.graphDiv,
      charting.data,
      {
         legend               : 'always',
         colors               : charting.colors,
         labels               : ['Time [s]', 'Amplitude', 'Peak Filter 1', 'Peak Filter 2'],
         labelsDiv            : charting.elements.labelsDiv,
         labelsSeparateLines  : true,
         visibility           : [true, false, false],
         axisLabelFontSize    : 12,
         axes: {
            x: {
               axisLabelFormatter: charting.msToDateConverter(false),
               valueFormatter: charting.msToDateConverter(true),
            }
         },
         drawCallback       : charting.drawCallback,
         highlightCallback  : charting.removeXLabelPlaceholder,
         unhighlightCallback: charting.addXLabelPlaceholder,
         zoomCallback       : charting.zoomCallback,
         interactionModel   : charting.interactionModel,
      });
   charting.graph = graph;

   charting.elements.rangeCheckbox.onchange = charting.toogleFixedRange;

   charting.elements.dataFilterCheckbox.onchange = charting.toogleData;
   charting.elements.peakFilterCheckbox1.onchange = charting.toogleFilterOptions1;
   charting.elements.peakFilterCheckbox2.onchange = charting.toogleFilterOptions2;
   charting.elements.peakFilterOptions1.style.display = "none";
   charting.elements.peakFilterOptions2.style.display = "none";

   graph.ready(function(g){
      charting.addXLabelPlaceholder();
   });
}

document.addEventListener('DOMContentLoaded', charting.buildChart);
</script>
<style>
   .chart-info {
      overflow: hidden;
      float: left;
      padding-left: 10px;
      min-width: 10%;
      padding: 15px;
   }

   .chart-info div {
      font-weight: bold;
   }

   .chart-info div span {
      color: black;
      font-weight: normal;
      display: block;
      float: right;
   }

   .clear {
      clear: both;
      height: 10px;
   }

   html {
      font-family: monospace;
   }

   #labels-div.empty:before {
      content: '-- time\00000A'
   }

   #labels-div:before {
      white-space: pre;
      content: 'time: ';
      font-weight: bold;
   }

   .dygraph-label.dygraph-xlabel,
   .dygraph-label.dygraph-ylabel {
      font-size: 1em;
      font-weight: bold;
      color: #757575;
   }

   #graph-title {
      text-align: left;
      font-size: 1em;
      font-weight: bold;
      color: #000;
   }

   #graph-div {
      height: 80%;
   }

   #container {
      width: 100%;
   }

   #left-panel {
      overflow: hidden;
      min-height: 100%;
   }

   #right-panel {
      float: right;
      width: 200px;
      min-height: 100%;
   }

   #user-tools {
      margin-top: 20px;
   }

   #filter-info {
      display: none;
   }
</style>
</head>
<body>
<div id="container">
   <div id="right-panel">
      <div id="labels-div" class="dygraph-legend"></div>
      <div id="user-tools">
         <label><input id="range-checkbox" type="checkbox"> Fixed Y axis </label>
         <br>
         <a href="https://chrome.google.com/webstore/detail/snipit/ehoadneljpdggcbbknedodolkkjodefl" target="_blank">or use sniplt</a>
         <br>
         <label><input id="data-filter-checkbox" type="checkbox" checked>Current Data</label>
         <br>
         <label><input id="peak-filter-checkbox-1" type="checkbox">Peak Filter Data - 1</label>
         <div id="peak-filter-options-1">
            <label>Upper Threshold</label>
            <input id="upper-threshold" type="number" value="900"><br>
            <label>Lower Threshold</label>
            <input id="lower-threshold" type="number" value="400"><br>
            <label>Frequency</label>
            <input id="frequency" type="number" value="60000">ms<br>
            <button onclick="charting.filterPeaks(this, 2)">Draw</button>
         </div>
         <label><input id="peak-filter-checkbox-2" type="checkbox">Peak Filter Data - 2</label>
         <div id="peak-filter-options-2">
            <label>Upper Threshold</label>
            <input id="upper-threshold" type="number" value="250"><br>
            <label>Lower Threshold</label>
            <input id="lower-threshold" type="number" value="100"><br>
            <label>Frequency</label>
            <input id="frequency" type="number" value="1250">ms<br>
            <button onclick="charting.filterPeaks(this, 3)">Draw</button>
         </div>
      </div>
      <p><b>Drag:</b> Zoom In</p>
      <p><b>Double Click:</b> Zoom Out</p>
      <p><b>Shift Drag:</b> Move</p>
      <button onclick="charting.restorePosition()">Restore View</button>
   </div>
   <div id="left-panel" >
      <div id="graph-div" ></div>
      <div id="statistics">
      </div>
   </div>
</div>
</body>
</html>
